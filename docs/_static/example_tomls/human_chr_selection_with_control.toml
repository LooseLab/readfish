# Summary: TOML config file configuring real-time basecalling and selective mapping of two chromosomes
# from the human genome.
# There are two regions specified.
# Each region divides 50% of the flowcell vertically.
# One region will act as a control and not implement any adaptive sampling.
# The other region will target Chr20 and 21 on the human genome.
# This example is configured for running with an R9.4.1 bulk file for testing.


# Genomic targets are specified directly in the toml file in the form
#   "contig"
# or as:
#   "contig,start,end,strand"
# for example, "chr2,0,100,+"" or "chr2".
# If chr2 is specified, the entire contig will be considered a target, on both strands.
# These patterns can be mixed, both in the toml or in a .csv file.

# All of the below fields are explained in more detail in the documentation -
# https://looselab.github.io/readfish/toml.html

# Basecaller configuration
[caller_settings.guppy]
#               ^^^^^^ - ".guppy" specifies our chosen basecaller
# Guppy base-calling configuration file name
config = "dna_r9.4.1_450bps_fast"
# Address of the guppy basecaller - The default address for guppy is ipc:///tmp/.guppy/5555.
address = "ipc:///tmp/.guppy/5555"
# Fastq output for individual reads. This is OPTIONAL - as these files can become quite large.
# Remove line to disable.
debug_log = "live_reads.fq"

# Aligner Configuration
[mapper_settings.mappy]
#               ^^^^^^ - ".mappy" specifies mappy or mappy-rs as the aligner
# Alignment reference to use. Should be either FASTA or an MMI
fn_idx_in = "/path/to/hg38.mmi"
# Optional PAF output for live alignments.
# Remove line to disable.
debug_log = "live_alignments.paf"
# Number of threads for indexing (mappy and mappy-rs) and mapping (mappy-rs only)
n_threads = 4


# Region Configuration - see https://looselab.github.io/readfish/toml.html#analysis-regions for more information.
# Definitions of "unblock", "proceed" and "stop_receivings" are as follows

    # proceed: Allow one more chunk to be captured, before trying to make another decision, i.e proceed for now

    # unblock: Unblock the read

    # stop_receiving: Allow the read to be sequenced, and stop receiving signal chunks for it.
[[regions]]
# Configuration for the first region.
name = "hum_test"
min_chunks = 1 # minimum number of chunks before a decision can be made
max_chunks = 4 # maximum number of chunks to use in decision making - after this perform the above_max_chunks action
targets = ["chr20", "chr21"]  # Genomic targets for this region.
single_on = "stop_receiving"  # Action to take if there is one mapping on target.
multi_on = "stop_receiving"   # Action to take if there is more than one mapping, with at least one target.
single_off = "unblock"        # Action to take if there is one mapping and it is off target
multi_off = "unblock"         # Action to take if there are multiple mappings, where all are off target.
no_seq = "proceed"            # Action to take if there is no sequence information
no_map = "proceed"            # Action to take if there is no mapping information
above_max_chunks = "unblock"  # Action to take if the number of chunks received is above max_chunks
below_min_chunks = "proceed"  # Action to take if the number of chunks received is below min_chunks

[[regions]]
# Configuration for the second region.
# As this is a control region, the targets field is effectively ignored.
# readfish will still call signal and map to the targets but will not implement any adaptive sampling.
name = "hum_control"
control = true # <-- Control field set to true (defaults false)
min_chunks = 1
max_chunks = 4
targets = ["chr20", "chr21"]
single_on = "stop_receiving"
multi_on = "stop_receiving"
single_off = "unblock"
multi_off = "unblock"
no_seq = "proceed"
no_map = "proceed"
above_max_chunks = "unblock"
below_min_chunks = "proceed"
